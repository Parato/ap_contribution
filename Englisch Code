import tkinter as tk
from tkinter import ttk
from itertools import combinations
from collections import Counter
import sys
import os

# Kategorien mit Werten
categories = {
    "Icon": [("Lesser Ancient Icon", 450), ("Ancient Icon", 900), ("Greater Ancient Icon", 1350), ("Major Ancient Icon", 1800)],
    "Seal": [("Lesser Ancient Seal", 900), ("Ancient Seal", 1800), ("Greater Ancient Seal", 2700), ("Major Ancient Seal", 3600)],
    "Goblet": [("Lesser Ancient Goblet", 1200), ("Ancient Goblet", 2400), ("Greater Ancient Goblet", 3600), ("Major Ancient Goblet", 4800)],
    "Crown": [("Lesser Ancient Crown", 2400), ("Ancient Crown", 4800), ("Greater Ancient Crown", 7200), ("Major Ancient Crown", 9600)],
}

item_names = []
values = []
for group, items in categories.items():
    for name, value in items:
        item_names.append(name)
        values.append(value)

quantities = [0] * len(item_names)
player_totals = [0, 0]
player_names = ["Player 1", "Player 2"]
max_players = 6
min_players = 2

def get_resource_path(relative_path):
    if hasattr(sys, '_MEIPASS'):  # PyInstaller packt die Dateien in _MEIPASS
        return os.path.join(sys._MEIPASS, relative_path)
    return os.path.join(os.path.abspath("."), relative_path)

def optimal_distribution(values, quantities, num_players):
    """Berechnet die optimale Verteilung der Gegenstände mit Berücksichtigung individueller Items."""
    # Erstelle eine Liste mit eindeutigen Identifikatoren für jeden Gegenstand
    all_items = []
    for i, (value, quantity) in enumerate(zip(values, quantities)):
        all_items.extend([(value, i)] * quantity)  # Der Index (i) macht jeden Gegenstand eindeutig

    def calculate_deviation(groups):
        sums = [sum(value for value, _ in group) for group in groups]
        return max(sums) - min(sums)

    if len(all_items) < num_players:
        return [[] for _ in range(num_players)], [0] * num_players, 0

    best_combination = None
    best_deviation = float('inf')

    # Erzeuge alle möglichen Gruppierungen
    for split_indices in combinations(range(len(all_items) + num_players - 1), num_players - 1):
        split_indices = [0] + [x + 1 for x in split_indices] + [len(all_items)]
        groups = [all_items[split_indices[i]:split_indices[i + 1]] for i in range(num_players)]
        deviation = calculate_deviation(groups)
        if deviation < best_deviation:
            best_combination = groups
            best_deviation = deviation

    # Extrahiere die Summen jeder Gruppe
    group_sums = [sum(value for value, _ in group) for group in best_combination]

    return best_combination, group_sums, best_deviation


def update_player_labels():
    """Aktualisiert die Anzeige der Spielernamen und Punktzahlen."""
    for i, frame in enumerate(player_frames):
        if i < len(player_names):
            for widget in frame.winfo_children():
                widget.destroy()

            tk.Label(frame, text=f"{player_names[i]}: {player_totals[i]}", anchor="w").pack(side="left")

            edit_button = ttk.Button(frame, text="Edit", command=lambda idx=i: edit_player_name(idx))
            edit_button.pack(side="right")
        else:
            for widget in frame.winfo_children():
                widget.destroy()


def edit_player_name(index):
    """Bearbeitet den Namen eines Spielers."""
    def save_name():
        new_name = entry.get()
        if new_name:
            player_names[index] = new_name
            update_player_labels()
        edit_window.destroy()

    edit_window = tk.Toplevel(root)
    edit_window.title("Edit Player Name")
    edit_window.iconbitmap(get_resource_path("deinicon.ico"))
    edit_window.geometry("280x150")
    tk.Label(edit_window, text="New Player Name:").pack(padx=10, pady=5)
    entry = ttk.Entry(edit_window)
    entry.insert(0, player_names[index])
    entry.pack(padx=10, pady=5)
    ttk.Button(edit_window, text="Save", command=save_name).pack(padx=10, pady=10)


def add_player():
    """Fügt einen neuen Spieler hinzu."""
    if len(player_names) < max_players:
        player_names.append(f"Player {len(player_names) + 1}")
        player_totals.append(0)
        update_player_labels()


def remove_player():
    """Entfernt den letzten Spieler."""
    if len(player_names) > min_players:
        player_names.pop()
        player_totals.pop()
        update_player_labels()


def change_quantity(index, delta):
    """Ändert die Menge eines Gegenstands."""
    quantities[index] = max(0, quantities[index] + delta)
    quantity_labels[index].config(text=str(quantities[index]))


def calculate():
    """Berechnet die optimale Verteilung der Gegenstände und ordnet sie den Spielern zu."""
    # Berechnung der optimalen Verteilung
    best_combination, group_sums, best_deviation = optimal_distribution(values, quantities, len(player_names))

    # Debug: Zeige die Gruppen und deren Summen
    print("\n--- Berechnung gestartet ---")
    print(f"Berechnete Gruppen: {best_combination}")
    print(f"Gruppensummen: {group_sums}")
    print(f"Abweichung der Verteilung: {best_deviation}")

    # Sortiere Spieler nach ihren aktuellen Punkteständen (aufsteigend)
    player_order = sorted(enumerate(player_totals), key=lambda x: x[1])  # (Index, Punktestand)
    print(f"\nSpieler sortiert nach Punkten: {[player_names[i] for i, _ in player_order]}")

    # Sortiere die berechneten Gruppen (Anteile) nach den Summen (absteigend)
    group_order = sorted(enumerate(group_sums), key=lambda x: x[1], reverse=True)  # (Index, Summe)
    print(f"Berechnete Anteile sortiert: {[sum for _, sum in group_order]}")

    # Ordne die Gruppen den Spielern zu
    assignment = [None] * len(player_names)
    for player, group in zip(player_order, group_order):
        player_idx = player[0]
        group_idx = group[0]
        assignment[player_idx] = group_idx
        print(f"-> {player_names[player_idx]} erhält Anteil mit Wert {group_sums[group_idx]}")

    # Aktualisiere Spielerpunkte und generiere Ergebnistext
    result_text = "Optimal Distribution:\n"
    for player_idx, group_idx in enumerate(assignment):
        if group_idx is not None:
            group = best_combination[group_idx]
            result_text += f"\n{player_names[player_idx]}:\n"
            item_count = Counter(group)
            for (value, index), count in item_count.items():
                name = item_names[index]
                result_text += f"  {count}x {name} (AP: {value})\n"
            result_text += f"  -> Total: {group_sums[group_idx]}\n"
            player_totals[player_idx] += group_sums[group_idx]

    print("\nErgebnis der Verteilung:")
    for i, points in enumerate(player_totals):
        print(f"{player_names[i]}: {points} Punkte")

    result_label.config(text=result_text)
    update_player_labels()

    # Setze die Mengen nach der Berechnung auf 0
    for i in range(len(quantities)):
        quantities[i] = 0
        quantity_labels[i].config(text="0")



def reset():
    """Setzt das Programm auf den Ursprung zurück (außer den Spielernamen)."""
    global quantities, player_totals

    quantities = [0] * len(item_names)
    player_totals = [0] * len(player_names)
    update_player_labels()

    for i in range(len(quantity_labels)):
        quantity_labels[i].config(text="0")

    result_label.config(text="")


root = tk.Tk()
icon_path = get_resource_path("deinicon.ico")
root.iconbitmap(icon_path)
root.title("AP Distribution")

top_frame = tk.Frame(root)
top_frame.pack(side="top", fill="x", padx=10, pady=10)

btn_add_player = ttk.Button(top_frame, text="Add Player", command=add_player)
btn_add_player.pack(side="left", padx=5)

btn_remove_player = ttk.Button(top_frame, text="Delete Player", command=remove_player)
btn_remove_player.pack(side="left", padx=5)

player_frame = tk.Frame(root)
player_frame.pack(fill="x", padx=10, pady=10)

player_frames = []
for i in range(max_players):
    frame = tk.Frame(player_frame)
    frame.pack(fill="x", pady=2)
    player_frames.append(frame)

update_player_labels()

left_frame = tk.Frame(root)
left_frame.pack(side="left", fill="both", expand=True, padx=10, pady=10)

right_frame = tk.Frame(root)
right_frame.pack(side="right", fill="both", expand=True, padx=10, pady=10)

quantity_labels = []
for category, items in categories.items():
    frame = tk.LabelFrame(left_frame, text=category)
    frame.pack(fill="x", padx=5, pady=5)

    for i, (name, value) in enumerate(items):
        item_frame = tk.Frame(frame)
        item_frame.pack(anchor="w", pady=2)

        tk.Label(item_frame, text=f"{name} (AP: {value}):", width=30, anchor="w").pack(side="left")
        minus_button = ttk.Button(item_frame, text="-", command=lambda idx=len(quantity_labels): change_quantity(idx, -1))
        minus_button.pack(side="left")

        lbl = tk.Label(item_frame, text="0", width=5)
        lbl.pack(side="left")
        quantity_labels.append(lbl)

        plus_button = ttk.Button(item_frame, text="+", command=lambda idx=len(quantity_labels)-1: change_quantity(idx, 1))
        plus_button.pack(side="left")

btn_calculate = ttk.Button(left_frame, text="Calculate", command=calculate)
btn_calculate.pack(pady=10)

btn_reset = ttk.Button(left_frame, text="Reset", command=reset)
btn_reset.pack(pady=10)

result_label = tk.Label(right_frame, text="", anchor="nw", justify="left")
result_label.pack(fill="both", expand=True)

root.mainloop()
