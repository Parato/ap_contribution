import tkinter as tk
from tkinter import ttk
from collections import Counter
import sys
import os


# Kategorien mit Werten
categories = {
    "Icon": [("Lesser Ancient Icon", 450), ("Ancient Icon", 900), ("Greater Ancient Icon", 1350), ("Major Ancient Icon", 1800)],
    "Seal": [("Lesser Ancient Seal", 900), ("Ancient Seal", 1800), ("Greater Ancient Seal", 2700), ("Major Ancient Seal", 3600)],
    "Goblet": [("Lesser Ancient Goblet", 1200), ("Ancient Goblet", 2400), ("Greater Ancient Goblet", 3600), ("Major Ancient Goblet", 4800)],
    "Crown": [("Lesser Ancient Crown", 2400), ("Ancient Crown", 4800), ("Greater Ancient Crown", 7200), ("Major Ancient Crown", 9600)],
}

item_names = []
values = []
for group, items in categories.items():
    for name, value in items:
        item_names.append(name)
        values.append(value)

quantities = [0] * len(item_names)
player_totals = [0, 0]
player_names = ["Player 1", "Player 2"]
max_players = 6
min_players = 2

def refresh_category_ui():
    """Erneuert die Anzeige der Kategorien im UI."""
    for widget in left_frame.winfo_children():
        widget.destroy()  # Alte UI-Elemente entfernen

    quantity_labels.clear()  # Labels für Mengen zurücksetzen

    # Kategorien neu aufbauen
    for i, (category, items) in enumerate(categories.items()):
        frame = tk.LabelFrame(left_frame, text=category)
        frame.pack(fill="x", padx=5, pady=5)

        for j, (name, value) in enumerate(items):
            item_frame = tk.Frame(frame)
            item_frame.pack(anchor="w", pady=2)

            tk.Label(item_frame, text=f"{name} (AP: {value}):", width=30, anchor="w").pack(side="left")
            minus_button = ttk.Button(item_frame, text="-", command=lambda idx=len(quantity_labels): change_quantity(idx, -1))
            minus_button.pack(side="left")

            lbl = tk.Label(item_frame, text="0", width=5)
            lbl.pack(side="left")
            quantity_labels.append(lbl)

            plus_button = ttk.Button(item_frame, text="+", command=lambda idx=len(quantity_labels)-1: change_quantity(idx, 1))
            plus_button.pack(side="left")




def get_resource_path(relative_path):
    if hasattr(sys, '_MEIPASS'):  # PyInstaller packt die Dateien in _MEIPASS
        return os.path.join(sys._MEIPASS, relative_path)
    return os.path.join(os.path.abspath("."), relative_path)

def optimal_distribution(values, quantities, num_players):
    """Berechnet die optimale Verteilung der Gegenstände mit Berücksichtigung individueller Items."""
    # Erstelle eine Liste mit eindeutigen Identifikatoren für jeden Gegenstand
    all_items = []
    for i, (value, quantity) in enumerate(zip(values, quantities)):
        all_items.extend([(value, i)] * quantity)  # Der Index (i) macht jeden Gegenstand eindeutig

    # Sortiere alle Items nach Wert (höchster Wert zuerst)
    all_items.sort(reverse=True, key=lambda x: x[0])

    # Initialisiere die Gruppen
    groups = [[] for _ in range(num_players)]
    group_sums = [0] * num_players

    # Verteile die Items so gleichmäßig wie möglich
    for item in all_items:
        # Finde die Gruppe mit der kleinsten Summe
        min_group_index = group_sums.index(min(group_sums))
        groups[min_group_index].append(item)
        group_sums[min_group_index] += item[0]

    # Berechne die Abweichung
    deviation = max(group_sums) - min(group_sums)

    return groups, group_sums, deviation

def update_player_labels():
    """Aktualisiert die Anzeige der Spielernamen und Punktzahlen."""
    for i, frame in enumerate(player_frames):
        if i < len(player_names):
            # Leere den Frame, bevor neue Widgets hinzugefügt werden
            for widget in frame.winfo_children():
                widget.destroy()

            # Stelle sicher, dass es drei Spalten gibt
            frame.grid_columnconfigure(0, weight=1, uniform="equal")  # Spalte für den Spielernamen
            frame.grid_columnconfigure(1, weight=1, uniform="equal")  # Spalte für die Punktzahl
            frame.grid_columnconfigure(2, weight=1, uniform="equal")  # Spalte für den Bearbeiten-Button

            # Der Spielername wird in der ersten Spalte platziert
            tk.Label(frame, text=f"{player_names[i]}", anchor="w").grid(row=0, column=0, sticky="w", padx=5)

            # Die Punktzahl wird in der zweiten Spalte platziert
            tk.Label(frame, text=f"{player_totals[i]} Abyss-Points", anchor="w").grid(row=0, column=1, sticky="w", padx=5)

            # Der Bearbeiten-Button wird in der dritten Spalte platziert
            edit_button = ttk.Button(frame, text="Edit", command=lambda idx=i: edit_player_name(idx))
            edit_button.grid(row=0, column=2, padx=5)

        else:
            for widget in frame.winfo_children():
                widget.destroy()


def edit_player_name(index):
    """Bearbeitet den Namen eines Spielers."""
    def save_name():
        new_name = entry.get()
        if new_name:
            player_names[index] = new_name
            update_player_labels()
        edit_window.destroy()

    edit_window = tk.Toplevel(root)
    edit_window.title("Edit Player Name")
    edit_window.iconbitmap(get_resource_path("deinicon.ico"))
    edit_window.geometry("320x150")
    tk.Label(edit_window, text="New Player Name:").pack(padx=10, pady=5)
    entry = ttk.Entry(edit_window)
    entry.insert(0, player_names[index])
    entry.pack(padx=10, pady=5)
    ttk.Button(edit_window, text="Save", command=save_name).pack(padx=10, pady=10)


def add_player():
    """Fügt einen neuen Spieler hinzu."""
    if len(player_names) < max_players:
        player_names.append(f"Player {len(player_names) + 1}")
        player_totals.append(0)
        update_player_labels()

def remove_player():
    """Entfernt den letzten Spieler."""
    if len(player_names) > min_players:
        player_names.pop()
        player_totals.pop()
        update_player_labels()

def change_quantity(index, delta):
    """Ändert die Menge eines Gegenstands."""
    quantities[index] = max(0, quantities[index] + delta)
    quantity_labels[index].config(text=str(quantities[index]))

def calculate():
    """Berechnet die optimale Verteilung der Gegenstände und ordnet sie den Spielern zu."""
    # Berechnung der optimalen Verteilung
    best_combination, group_sums, best_deviation = optimal_distribution(values, quantities, len(player_names))

    # Debug: Zeige die Gruppen und deren Summen
    print("\n--- Berechnung gestartet ---")
    print(f"Berechnete Gruppen: {best_combination}")
    print(f"Gruppensummen: {group_sums}")
    print(f"Abweichung der Verteilung: {best_deviation}")

    # Sortiere Spieler nach ihren aktuellen Punkteständen (aufsteigend)
    player_order = sorted(enumerate(player_totals), key=lambda x: x[1])  # (Index, Punktestand)
    print(f"\nSpieler sortiert nach Punkten: {[player_names[i] for i, _ in player_order]}")

    # Sortiere die berechneten Gruppen (Anteile) nach den Summen (absteigend)
    group_order = sorted(enumerate(group_sums), key=lambda x: x[1], reverse=True)  # (Index, Summe)
    print(f"Berechnete Anteile sortiert: {[sum for _, sum in group_order]}")

    # Ordne die Gruppen den Spielern zu
    assignment = [None] * len(player_names)
    for player, group in zip(player_order, group_order):
        player_idx = player[0]
        group_idx = group[0]
        assignment[player_idx] = group_idx
        print(f"-> {player_names[player_idx]} erhält Anteil mit Wert {group_sums[group_idx]}")

    # Aktualisiere Spielerpunkte und generiere Ergebnistext
    result_text = "Optimal Distribution:\n"
    for player_idx, group_idx in enumerate(assignment):
        if group_idx is not None:
            group = best_combination[group_idx]
            result_text += f"\n{player_names[player_idx]}:\n"
            item_count = Counter(group)
            for (value, index), count in item_count.items():
                name = item_names[index]
                result_text += f"  {count}x {name} (AP: {value})\n"
            result_text += f"  -> Total: {group_sums[group_idx]} Abyss-Points\n"
            player_totals[player_idx] += group_sums[group_idx]

    print("\nErgebnis der Verteilung:")
    for i, points in enumerate(player_totals):
        print(f"{player_names[i]}: {points} Punkte")

    result_label.config(text=result_text)
    update_player_labels()

    # Setze die Mengen nach der Berechnung auf 0
    for i in range(len(quantities)):
        quantities[i] = 0
        quantity_labels[i].config(text="0")

def reset():
    """Setzt das Programm auf den Ursprung zurück (außer den Spielernamen)."""
    global quantities, player_totals

    quantities = [0] * len(item_names)
    player_totals = [0] * len(player_names)
    update_player_labels()

    for i in range(len(quantity_labels)):
        quantity_labels[i].config(text="0")

    result_label.config(text="")

root = tk.Tk()
icon_path = get_resource_path("deinicon.ico")
root.iconbitmap(icon_path)
root.title("AP Distribution")
root.geometry("1300x600")

# Canvas und Scrollbar einrichten
canvas = tk.Canvas(root)
vertical_scrollbar = tk.Scrollbar(root, orient="vertical", command=canvas.yview)
canvas.configure(yscrollcommand=vertical_scrollbar.set)

canvas.pack(side="left", fill="both", expand=True)
vertical_scrollbar.pack(side="right", fill="y")

scrollable_frame = tk.Frame(canvas)

scrollable_frame.bind(
    "<Configure>",
    lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
)

canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

# Erstelle UI-Elemente im scrollbaren Bereich
top_frame = tk.Frame(scrollable_frame)
top_frame.pack(side="top", fill="x", padx=10, pady=10)




optimal_distribution_frame = tk.Frame(scrollable_frame)
optimal_distribution_frame.pack(side="right", fill="x", padx=10, pady=10)

btn_add_player = ttk.Button(top_frame, text="Add Player", command=add_player)
btn_add_player.pack(side="left", padx=5)

btn_remove_player = ttk.Button(top_frame, text="Delete Player", command=remove_player)
btn_remove_player.pack(side="left", padx=5)

player_frame = tk.Frame(scrollable_frame)
player_frame.pack(fill="x", padx=10, pady=10)

player_frames = []  # Make sure this is defined before use

for i in range(max_players):
    frame = tk.Frame(player_frame)
    frame.pack(fill="x", pady=2)
    player_frames.append(frame)

update_player_labels()

left_frame = tk.Frame(scrollable_frame)
left_frame.pack(side="left", fill="both", expand=True, padx=10, pady=10)

right_frame = tk.Frame(scrollable_frame)
right_frame.pack(side="right", fill="both", expand=True, padx=10, pady=10)

quantity_labels = []

# Anordnung der Kategorien in 2er Blöcken
category_frames = []
for i, (category, items) in enumerate(categories.items()):
    if i % 2 == 0:
        row_frame = tk.Frame(left_frame)
        row_frame.pack(fill="x", padx=5, pady=5)
        category_frames.append(row_frame)

    frame = tk.LabelFrame(category_frames[-1], text=category)
    frame.pack(side="left", fill="x", padx=5, pady=5)

    for j, (name, value) in enumerate(items):
        item_frame = tk.Frame(frame)
        item_frame.pack(anchor="w", pady=2)

        tk.Label(item_frame, text=f"{name} (AP: {value}):", width=30, anchor="w").pack(side="left")
        minus_button = ttk.Button(item_frame, text="-", command=lambda idx=len(quantity_labels): change_quantity(idx, -1))
        minus_button.pack(side="left")

        lbl = tk.Label(item_frame, text="0", width=5)
        lbl.pack(side="left")
        quantity_labels.append(lbl)

        plus_button = ttk.Button(item_frame, text="+", command=lambda idx=len(quantity_labels)-1: change_quantity(idx, 1))
        plus_button.pack(side="left")

btn_calculate = ttk.Button(left_frame, text="Calculate", command=calculate)
btn_calculate.pack(pady=10)

btn_reset = ttk.Button(left_frame, text="Reset", command=reset)
btn_reset.pack(pady=10)

result_label = tk.Label(right_frame, text="", anchor="nw", justify="left")
result_label.pack(fill="both", expand=True)

# Scrollen mit dem Mausrad aktivieren
def on_mouse_wheel(event):
    canvas.yview_scroll(int(-1*(event.delta/120)), "units")

root.bind_all("<MouseWheel>", on_mouse_wheel)

root.mainloop()
